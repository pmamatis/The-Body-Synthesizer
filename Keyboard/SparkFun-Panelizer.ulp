#usage "en: <b>Copy a given board to fill a panel. Panel size is given by user. Add panel borders if requested. Add gaps as requested. Add V-score lines and labels as requested.</b> PCBWay requires the user to create panels that are at least 75x75mm. If the panel is smaller than this they will reject it because their v-score machine can't handle it. This ULP takes a given design and replicates it until the panel is just over the dimensions specified by the user. It also adds dimension lines between copies and v-score text so that PCBWay knows where to v-score. This script will also detect overhanging parts and warn the user that gaps are needed. Script tries to identify the soldermask color based on the logos on the board (SparkFun vs SparkX vs LilyPad). Script looks for 0.8mm tag for thin boards. Script outputs a ordering_instructions.txt file containing all the characteristics of this panel."
"<p>Usage: run sparkfun-panelizer</p>"
	"<p>Author: <author>Nathan Seidle &lt;inathan@sparkfun.com&gt;</author><br />"
	"Version: <em>1.0</em></p>"

	//Original board dimension code came from https://gist.github.com/itavero/8042433

	string bigScript = ""; //The big string of commands that we will eventually run as a script

/*
	Run this ULP from the board you would like to panelize.
*/
// sprintf(s, "Width: %f", panelWidth);
// dlgMessageBox(s);
// exit(-1);

string designRulesLocation; //Used to store the temp location of the DRU file for the original design
string s = "";

char configFileExists = 0; // used to know if we want to populate recommended settings on a "fresh" use of this ULP.

//Config options we want to save
real verticalGap = 0.02; //PCBWay needs at least 0.02 inches between copies
real horizontalGap = 0.02;
real panelSizeX = 5.5;
real panelSizeY = 7.5;
int vScoreIndicators = 0;
int drawPanelBorders = 0;
int exposeCardEdge = 0;
int runCAM = 0;
int generateTopStencil = 0;
int generateBottomStencil = 0;
int panelUnits = 0;						//Default to inches
int panelMustBeLargerThanDimension = 0; //Default to 'must be less than'
int leftRightFiducials = 0;				// Move panel fiducials to the left and right sides (instead of top and bottom)

//Get the name of this brd (no extension, no directory)
string get_project_name()
{
	if (board)
		board(B) return (filesetext(filename(B.name), ""));
	if (schematic)
		schematic(B) return (filesetext(filename(B.name), ""));
}

string get_project_path()
{
	if (board)
		board(B) return (filedir(B.name));
	if (schematic)
		schematic(B) return (filedir(B.name));
}

void configWrite()
{
	//Get the name of this brd (no extension, no directory)
	string baseFileName = get_project_name();
	string configFile = get_project_path() + "Production/" + baseFileName + "-PanelizerSettings.txt";

	output(configFile)
	{
		printf("%.5f\n", verticalGap);
		printf("%.5f\n", horizontalGap);
		printf("%.5f\n", panelSizeX);
		printf("%.5f\n", panelSizeY);
		printf("%d\n", vScoreIndicators);
		printf("%d\n", drawPanelBorders);
		printf("%d\n", runCAM);
		printf("%d\n", generateTopStencil);
		printf("%d\n", generateBottomStencil);
		printf("%d\n", panelUnits);
		printf("%d\n", panelMustBeLargerThanDimension);
		printf("%d\n", exposeCardEdge);
		printf("%d\n", leftRightFiducials);
	}
}

void configRead()
{
	//Get the name of this brd (no extension, no directory)
	string baseFileName = get_project_name();
	string configFile = get_project_path() + "Production/" + baseFileName + "-PanelizerSettings.txt";

	if (filesize(configFile))
	{						  //Check if file exists
		configFileExists = 1; // used to know if this is a "fresh" use of the ULP.
		string data[];
		int line = fileread(data, configFile);
		if (line >= 4)
		{
			verticalGap = strtod(data[0]);
			horizontalGap = strtod(data[1]);
			panelSizeX = strtod(data[2]);
			panelSizeY = strtod(data[3]);
			vScoreIndicators = strtol(data[4]);
			drawPanelBorders = strtol(data[5]);
			runCAM = strtol(data[6]);
			generateTopStencil = strtol(data[7]);
			generateBottomStencil = strtol(data[8]);
			panelUnits = strtol(data[9]);
			panelMustBeLargerThanDimension = strtol(data[10]);
			exposeCardEdge = strtol(data[11]);
			leftRightFiducials = strtol(data[12]);
		}
	}
}

real designWidth; //In inches
real designHeight;
real recPanelWidth;
real recPanelHeight;
real xMax = 0;
real yMax = 0;
real xMin = -1000;
real yMin = -1000;
real xOutlyingMax = -100;
real xOutlyingMin = 100;
real yOutlyingMax = -100;
real yOutlyingMin = 100;

real panelWidth = 0;
real panelHeight = 0;

int numberOfColumns = 0;
int numberOfRows = 0;

string overHangingParts = "false";
real verticalGapNeeded = 0;
real horizontalGapNeeded = 0;

string panelFileLocation = "";

string bottomPackages = "";

int false = 0;
int true = 1;

//Finds a string in a string no matter where, no matter capitalization
int containsString(string toSearch, string toFind)
{
	int pos = strstr(strlwr(toSearch), strlwr(toFind));
	if (pos >= 0) //String found
	{
		return (1);
	}

	return (0);
}

//Detect if board has four layers
//This was re-written to scan only for signal wires on internals layers becaused things like a microB connector uses polygons on layers 2/15
int hasFourLayers()
{
	//Old way
	/*board(B) {
		B.layers(L) {
			if(L.used  == 1 && L.number == 2)
			{
				return(1);
			}
			if(L.used == 1 && L.number == 15)
			{
				return(1);
			}
		}
	}*/

	board(B)
	{
		B.signals(S)
		{
			S.wires(W)
			{
				if (W.layer == 2)
				{
					return (1);
				}
				if (W.layer == 15)
				{
					return (1);
				}
			}
		}
	}
	return (0); //Nope
}

//Detect if board has six layers
int hasSixLayers()
{
	board(B)
	{
		B.signals(S)
		{
			S.wires(W)
			{
				if (W.layer == 3)
				{
					return (1);
				}
				if (W.layer == 14)
				{
					return (1);
				}
			}
		}
	}
	return (0); //Nope
}

//Detect if parts are on a given layer of the board
int hasPartsOnLayer(int layerNumber)
{
	board(B)
	{
		B.elements(E)
		{
			E.package.contacts(C)
			{
				if (C.smd && C.smd.layer == layerNumber)
				{

					//Ignore
					//Fiducials, jumpers with traces as closure method, jumpers that are normally open
					if (containsString(E.package.name, "fiducial") == 0 && containsString(E.package.name, "NC_TRACE") == 0 && containsString(E.package.name, "NC_BY_TRACE") == 0 && containsString(E.package.name, "SJ_2S-NO") == 0 && containsString(E.package.name, "SMT-JUMPER") == 0 && containsString(E.package.name, "USB-MICROB-PTH-MILL") == 0 && containsString(E.package.name, "USB-C") == 0 && containsString(E.package.name, "PAD.03X.03") == 0 //Test points
						&& containsString(E.package.name, "PAD.03X.05") == 0 && containsString(E.package.name, "USB-SOLDER-PADS") == 0)
					{
						//String not found, this is a legit part
						bottomPackages += E.package.name + ",";
						return (1);
					}
				}
			}
		}
	}

	return (0); //Nope
}

//Detect if parts are on the top of the board
int hasTopParts()
{
	return (hasPartsOnLayer(1));
}

//Detect if parts are on the bottom of the board
int hasBottomParts()
{
	return (hasPartsOnLayer(16));
}

//Convert a number of inches to mm
real convertInchToMM(real inches)
{
	real mm = inches / 0.039370;
	int partialMM = (mm * 100 + .5);
	mm = partialMM / 100.0;
	return (mm);
}

//Convert a number of mm to inches
real convertMMToInches(real mm)
{
	real inches = mm * 0.039370;
	//int partialInches = (inches * 100 + .5); //This causes the minTrackWidth calc to return 0
	//inches = partialInches / 100.0;
	return (inches);
}

//Detect thickness of board.
//If the board contains the text "0.8mm thickness" or "board thickness is 0.8mm" it returns 0.8mm.
//This is a bit of a hack but all thin SparkFun designs call out the thickness in the BRD file
string getBoardThickness()
{
	//Search the ordering instructions box
	board(B)
	{
		B.texts(T)
		{
			if (containsString(T.value, "0.8mm Thickness") == 1)
			{
				return ("0.8mm");
			}
			if (containsString(T.value, "Board Thickness is 0.8mm") == 1)
			{
				return ("0.8mm");
			}
			if (containsString(T.value, "1.6mm Thickness") == 1)
			{
				return ("1.6mm");
			}
			if (containsString(T.value, "Board Thickness is 1.6mm") == 1)
			{
				return ("1.6mm");
			}
		}
	}

	dlgMessageBox("Warning: Board thickness not found. Assuming 1.6mm");
	return ("1.6mm");
}

//Detect copper weight (thickness).
//If someone has put "2oz" in any of the text on the board then return "2oz" else return "1oz".
string getCopperWeight()
{
	//Search the ordering instructions box
	board(B)
	{
		B.texts(T)
		{
			if (containsString(T.value, "2oz") == 1)
			{
				return ("2oz");
			}
		}
	}

	return ("1oz");
}

//Search through logos on board to determine if this is a SparkX board (black)
//SparkFun board (red), LilyPad (purple) or other (green as default)
string getBoardColor()
{
	int sparkxFound = 0;
	int sparkfunFound = 0;
	int lilypadFound = 0;
	int spectacleFound = 0;
	int microBitFound = 0;

	//Search the ordering instructions box
	board(B)
	{
		B.texts(T)
		{
			if (containsString(T.value, "Solder Mask") == 1)
			{
				if (containsString(T.value, "Matte Black") == 1)
				{
					return ("Matte Black");
				}
				if (containsString(T.value, "Black") == 1)
				{
					return ("Black");
				}
				if (containsString(T.value, "Purple") == 1)
				{
					return ("Purple");
				}
			}
		}
	}

	board(B)
	{
		B.elements(E)
		{

			if (containsString(E.package.name, "SparkX") == 1) //String found
			{
				sparkxFound = 1;
			}

			if (containsString(E.package.name, "SparkFun") == 1 || containsString(E.package.name, "SFE") == 1) //String found
			{
				sparkfunFound = 1;
			}

			if (containsString(E.package.name, "Spectacle") == 1) //String found
			{
				spectacleFound = 1;
			}

			if (containsString(E.package.name, "LilyPad") == 1 || containsString(E.package.library, "LilyPad") == 1) //String found
			{
				lilypadFound = 1;
			}
		}
	}

	if (sparkxFound == 1 && sparkfunFound == 0 && lilypadFound == 0 && spectacleFound == 0)
	{
		return ("Black");
	}
	if (sparkxFound == 0 && sparkfunFound == 1 && lilypadFound == 0 && spectacleFound == 0)
	{
		return ("Red");
	}
	if (sparkxFound == 0 && sparkfunFound == 0 && lilypadFound == 1 && spectacleFound == 0)
	{
		return ("Purple");
	}
	if (sparkxFound == 0 && sparkfunFound == 1 && lilypadFound == 0 && spectacleFound == 1)
	{
		return ("Black");
	}

	string warning = "Not sure what board color to use.";
	if (sparkxFound == 1)
		warning += " SparkX found.";
	if (sparkfunFound == 1)
		warning += " SparkFun found.";
	if (lilypadFound == 1)
		warning += " LilyPad found.";
	if (spectacleFound == 1)
		warning += " Spectacle found.";
	if (sparkxFound == 0 && sparkfunFound == 0 && lilypadFound == 0 && spectacleFound == 0)
		warning += " No logos found.";

	warning += " Marking as unknown.";

	dlgMessageBox(warning);
	return ("Unknown");
}

//Search for the surface finish
//Currently only searches for ENIG or HASL. Defaults to "HASL lead free"
string getSurfaceFinish()
{
	//Search the ordering instructions box
	board(B)
	{
		B.texts(T)
		{
			if (containsString(T.value, "ENIG") == 1)
			{
				return ("ENIG");
			}
			if (containsString(T.value, "enig") == 1)
			{
				return ("ENIG");
			}
			if (containsString(T.value, "HASL") == 1)
			{
				return ("HASL lead free");
			}
			if (containsString(T.value, "hasl") == 1)
			{
				return ("HASL lead free");
			}
		}
	}

	//string warning = "Not sure what board finish to use. Defaulting to HASL lead free.";
	//dlgMessageBox(warning);
	return ("HASL lead free");
}

//Look at the origins for all the elements. Find the largest outlying coordinate.
//These values are used to appropriately set the oversize amount of the copy frame
void getOutlyingOrigins()
{
	real outlyingCoordinate = 0;
	board(B)
	{
		B.elements(E)
		{

			//There are some elements we need to ignore, for example the
			//Special instruction box is all tDocu and always far outside the board outline
			if (E.package.name == "CREATIVE_COMMONS" || E.package.name == "ORDERING_INSTRUCTIONS" || E.package.name == "PRODUCTION_INSTRUCTIONS" || E.package.name == "DUMMY") //Ignore Dummy anchor used with multi-schematic frames
			{
				//Ignore the location of this element
			}
			else
			{

				//Find the largest outlying coordinate
				if (u2inch(E.x) > xOutlyingMax)
					xOutlyingMax = u2inch(E.x);
				if (u2inch(E.x) < xOutlyingMin)
					xOutlyingMin = u2inch(E.x);
				if (u2inch(E.y) > yOutlyingMax)
					yOutlyingMax = u2inch(E.y);
				if (u2inch(E.y) < yOutlyingMin)
					yOutlyingMin = u2inch(E.y);

			} //End ignore list
		}	  //End Elements
	}

	//Increase outliers to at least the x/y Min/Max values
	if (xMax > xOutlyingMax)
		xOutlyingMax = xMax;
	if (xMin < xOutlyingMin)
		xOutlyingMin = xMin;
	if (yMax > yOutlyingMax)
		yOutlyingMax = yMax;
	if (yMin < yOutlyingMin)
		yOutlyingMin = yMin;
}

//We need to preserve the DRC settings from the original design into the panel
//To do that, we save the DRC file of the original into the production folder
//then load it once the panel is created
//then remove it
void saveDRCfile()
{
	sprintf(s, "DRC SAVE '%s';\n", designRulesLocation);
	bigScript += s;
}

void loadDRCfile()
{
	sprintf(s, "DRC LOAD '%s';\n", designRulesLocation);
	bigScript += s;
}

//Assumes all variables have been set to inch units
void panelizer()
{
	real borderWidth = 0;
	if (drawPanelBorders == 1)
		borderWidth = 0.25;

	//Calculate the number of copies we need to achieve our min panel size
	while ((numberOfColumns * (designWidth + verticalGap) + verticalGap) + (borderWidth * 2) < panelSizeX)
		numberOfColumns++;
	while ((numberOfRows * (designHeight + horizontalGap) + horizontalGap) + (borderWidth * 2) < panelSizeY)
		numberOfRows++;
	if (panelMustBeLargerThanDimension == 0)
	{
		numberOfColumns--;
		numberOfRows--;
	}

	if (numberOfRows <= 0 || numberOfColumns <= 0)
	{
		dlgMessageBox("The number of columns or rows was 0. Please increase X/Y panel size for this design.");
		exit(-1);
	}

	//numberOfRows = ceil(panelSizeY / (designHeight + horizontalGap));
	//if(numberOfRows * (designHeight + horizontalGap) + horizontalGap < panelSizeY) numberOfRows++;

	panelWidth = (designWidth + verticalGap) * numberOfColumns - verticalGap;
	panelWidth += borderWidth * 2;
	if (drawPanelBorders == 1)
		panelWidth += (verticalGap * 2);

	panelHeight = (designHeight + horizontalGap) * numberOfRows - horizontalGap;
	panelHeight += borderWidth * 2;
	if (drawPanelBorders == 1)
		panelHeight += (horizontalGap * 2);

	// string x;
	// sprintf(x, "%f", panelHeight * 25.4);
	// dlgMessageBox(x);

	//Check to see if panel is big enough for v-scoring
	//Min size is 7cm x 7cm if v-scoring is required
	if (vScoreIndicators == 1)
	{
		if (panelWidth < 2.75 || panelHeight < 2.75)
		{
			dlgMessageBox("Fab houses require a panel to be larger than 2.75\" on side to fit into their v-scoring machine. Please increase the size of your panel.");
			exit(-1);
		}
	}

	//If we need a chamfered edge then we have to expose the panel edge.
	//If we need to expose the panel edge then we can't have more than two rows
	if (exposeCardEdge == 1)
	{
		if (numberOfRows > 2)
			numberOfRows = 2;

		//Adjust the panelHeight to 70mm. We need only two rows, no top/bottom borders
		panelHeight = 2.75;

		//If 2 * design height is > 70mm then we need to insert a quarter inch 'dead' area
		if (designHeight * 2 > 2.75)
			panelHeight = designHeight * 2 + 0.25;
	}

	saveDRCfile(); //Save the DRC file for this board to a temp location so we can load it in the panel

	//Tun on all layers for copying
	bigScript += "DISPLAY ALL;\n"; //Copy everything

	getOutlyingOrigins(); //Find the origins of any element that fall outside the dimension lines

	real copyOversizeAmount = 0.05; //Amount of overhang past the outlying origins

	//Draw a box slightly larger that the dimensions of the board
	real lowerX = xOutlyingMin - copyOversizeAmount;
	real lowerY = yOutlyingMin - copyOversizeAmount;
	real upperX = xOutlyingMax + copyOversizeAmount;
	real upperY = yOutlyingMax + copyOversizeAmount;

	bigScript += "GRID INCH 0.05 ON;\n";

	sprintf(s, "GROUP (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f);\n", lowerX, lowerY, upperX, lowerY, upperX, upperY, lowerX, upperY, lowerX, lowerY);
	bigScript += s;

	//Cut from the lower left corner of group
	sprintf(s, "CUT (%.4f %.4f);\n", xMin, yMin);
	bigScript += s;

	//Create new board file
	bigScript += "SET CONFIRM YES;\n";
	sprintf(s, "EDIT '%s';\n", panelFileLocation);
	bigScript += s;
	bigScript += "SET CONFIRM OFF;\n";

	//Go back to inch grid
	bigScript += "GRID INCH 0.05 ON;GRID ALT INCH 0.005;\n";

	//Turn on all layers
	bigScript += "DISPLAY ALL;\n";

	//Paste the copies to fill the panel
	real xCoord = 0;
	real yCoord = 0;
	for (int row = 0; row < numberOfRows; row++)
	{
		for (int column = 0; column < numberOfColumns; column++)
		{
			xCoord = (column * designWidth) + (column * verticalGap);
			yCoord = (row * designHeight) + (row * horizontalGap);

			bigScript += "SET CONFIRM YES;\n";

			if (exposeCardEdge == 0)
			{
				//If card edge is not required, just paste the design
				sprintf(s, "PASTE (%.4f %.4f);\n", xCoord, yCoord);
			}
			else
			{
				//If we do need card edge exposed, rotate the design on the upper row
				if (row == 0)
				{
					//Normal paste
					sprintf(s, "PASTE (%.4f %.4f);\n", xCoord, yCoord);
				}
				else
				{
					xCoord = (column * designWidth + designWidth) + (column * verticalGap);

					//Move yCoord far up so that this design butts against the upper edge
					//For designs that are smaller than 7cm on a side, this will open space
					//in the middle of the board
					yCoord = panelHeight;

					//Paste with rotation
					sprintf(s, "PASTE R180 (%.4f %.4f);\n", xCoord, yCoord);
				}
			}

			bigScript += s;
			bigScript += "SET CONFIRM OFF;\n";

			//Add 'route out' text if the gap between boards is large
			if (verticalGap > 0.05)
			{
				bigScript += "LAYER 20;\n"; //Dimension layer
				sprintf(s, "CHANGE ALIGN CENTER; CHANGE SIZE 0.07; CHANGE RATIO 15; TEXT 'Route Out' R90 (%.4f %.4f);\n", xCoord - (verticalGap / 2), yCoord + (designHeight / 2));
				bigScript += s;

				if (column == numberOfColumns - 1) //Add last text
				{
					bigScript += "LAYER 20;\n"; //Dimension layer
					sprintf(s, "CHANGE ALIGN CENTER; CHANGE SIZE 0.07; CHANGE RATIO 15; TEXT 'Route Out' R90 (%.4f %.4f);\n", xCoord + (verticalGap / 2) + designWidth, yCoord + (designHeight / 2));
					bigScript += s;
				}
			}

			if (horizontalGap > 0.05)
			{
				bigScript += "LAYER 20;\n"; //Dimension layer
				sprintf(s, "CHANGE ALIGN CENTER; CHANGE SIZE 0.07; CHANGE RATIO 15; TEXT 'Route Out' (%.4f %.4f);\n", xCoord + (designWidth / 2), yCoord - (horizontalGap / 2));
				bigScript += s;

				if (row == numberOfRows - 1) //Add last text
				{
					bigScript += "LAYER 20;\n"; //Dimension layer
					sprintf(s, "CHANGE ALIGN CENTER; CHANGE SIZE 0.07; CHANGE RATIO 15; TEXT 'Route Out' (%.4f %.4f);\n", xCoord + (designWidth / 2), yCoord + (horizontalGap / 2) + designHeight);
					bigScript += s;
				}
			}
		}
	}

	//Draw v-score lines between copies
	if (vScoreIndicators == 1)
	{
		bigScript += "LAYER 46;\n"; //Milling layer
		//We avoid drawing on the dimension layer because the Eagle to Charm conversion checks the board size
		//based on dimension artifacts

		//If the vertical gap is large enough for route outs don't draw v-score lines/text
		if (verticalGap < 0.05)
		{
			//Add vertical lines
			int column = 1;
			int linesToDraw = numberOfColumns;
			if (drawPanelBorders == 1)
			{
				column = 0;
				linesToDraw++;
			}

			for (; column < linesToDraw; column++)
			{
				xCoord = ((designWidth + (verticalGap / 2)) * column) + ((column - 1) * (verticalGap / 2));

				real yCoordLow = 0;
				yCoordLow -= (borderWidth + horizontalGap);

				real yCoordHigh = panelHeight - (borderWidth * 2) + 0.25;

				if (exposeCardEdge == 1)
				{
					yCoordHigh = panelHeight + 0.25;
				}

				sprintf(s, "WIRE 0.015 (%.4f %.4f) (%.4f %.4f);\n", xCoord, yCoordLow, xCoord, yCoordHigh);
				bigScript += s;

				//Add the word 'v-score' lines
				sprintf(s, "CHANGE ALIGN CENTER; CHANGE SIZE 0.07; CHANGE RATIO 15; TEXT v-score (%.4f %.4f);\n",
						xCoord,
						yCoordHigh + 0.09);
				bigScript += s;

				if (exposeCardEdge == 1)
				{
					if (column < linesToDraw - 1)
					{
						//Add the word 'Do not remove' to the inner panel
						sprintf(s, "CHANGE ALIGN CENTER; CHANGE SIZE 0.07; CHANGE RATIO 15;  TEXT 'Do not remove' (%.4f %.4f);\n",
								xCoord + (designWidth / 2),
								panelHeight / 2);
						bigScript += s;
					}
				}
			}
		}

		//If the vertical gap is large enough for route outs don't draw v-score lines/text
		if (horizontalGap < 0.05)
		{
			//Add horizontal lines
			int row = 1;
			int linesToDraw = numberOfRows;

			if (drawPanelBorders == 1)
			{
				linesToDraw++;
				if (exposeCardEdge == 0)
				{
					row = 0;
				}
			}

			for (; row < linesToDraw; row++)
			{
				yCoord = ((designHeight + (horizontalGap / 2)) * row) + ((row - 1) * (horizontalGap / 2));

				if (exposeCardEdge == 1 && row == 2)
				{
					yCoord = panelHeight - designHeight - (horizontalGap / 2);
				}

				real xCoordLow = 0;
				xCoordLow -= (borderWidth + verticalGap);

				real xCoordHigh = (numberOfColumns * designWidth) + (numberOfColumns * verticalGap) + 0.25;
				xCoordHigh += borderWidth; //Extend past the frame if exists

				sprintf(s, "WIRE 0.015 (%.4f %.4f) (%.4f %.4f);\n", xCoordLow, yCoord, xCoordHigh, yCoord);
				bigScript += s;

				//Add the word 'v-score' lines
				sprintf(s, "CHANGE ALIGN CENTER; CHANGE SIZE 0.07; CHANGE RATIO 15;  TEXT v-score (%.4f %.4f);\n", xCoordHigh + 0.3, yCoord);
				bigScript += s;
			}
		}
	}

	//Add borders to four sides
	if (drawPanelBorders == 1)
	{
		bigScript += "LAYER 20;\n"; //Dimension layer

		//Draw lower box
		real lowerXleft = 0 - verticalGap - borderWidth;
		real lowerXright = panelWidth - borderWidth - verticalGap;
		real lowerYupper = 0 - horizontalGap;
		real lowerYlower = lowerYupper - borderWidth;

		if (exposeCardEdge == 0)
		{
			//Don't expose the card edge. Draw the lower border
			sprintf(s, "WIRE 0.01 (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f);\n",
					lowerXleft, lowerYupper,
					lowerXright, lowerYupper,
					lowerXright, lowerYlower,
					lowerXleft, lowerYlower,
					lowerXleft, lowerYupper);
			bigScript += s;
		}

		//Draw right box
		real rightXleft = panelWidth - verticalGap - (borderWidth * 2); //panelWidth includes borders as needed, but X starts at 0-borderWidth
		real rightXright = rightXleft + borderWidth;
		real rightYupper = panelHeight - horizontalGap - (borderWidth * 2) - 0.02;
		if (exposeCardEdge == 1)
			rightYupper = panelHeight;

		real rightYlower = 0 - horizontalGap + 0.02;

		sprintf(s, "WIRE 0.01 (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f);\n",
				rightXleft, rightYupper,
				rightXright, rightYupper,
				rightXright, rightYlower,
				rightXleft, rightYlower,
				rightXleft, rightYupper);
		bigScript += s;

		//Draw top box
		real topXleft = 0 - verticalGap - borderWidth;
		real topXright = panelWidth - borderWidth - verticalGap;
		real topYlower = panelHeight - (borderWidth * 2) - horizontalGap;
		real topYupper = panelHeight - borderWidth - horizontalGap;

		if (exposeCardEdge == 0)
		{
			//Don't expose the card edge. Draw the upper border
			sprintf(s, "WIRE 0.01 (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f);\n",
					topXleft, topYupper,
					topXright, topYupper,
					topXright, topYlower,
					topXleft, topYlower,
					topXleft, topYupper);
			bigScript += s;
		}

		//Draw left box
		real leftXleft = 0 - borderWidth - verticalGap;
		real leftXright = 0 - verticalGap;
		real leftYlower = 0 - horizontalGap + 0.02;
		real leftYupper = panelHeight - horizontalGap - (borderWidth * 2) - 0.02;
		if (exposeCardEdge == 1)
			leftYupper = panelHeight;

		sprintf(s, "WIRE 0.01 (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f) (%.4f %.4f);\n",
				leftXleft, leftYupper,
				leftXright, leftYupper,
				leftXright, leftYlower,
				leftXleft, leftYlower,
				leftXleft, leftYupper);
		bigScript += s;

		//Add three fiducials so that the panel cannot be reversed in the machine without CV noticing

		//Upper two fiducials live on one breakaway edge
		//Fiducials are not in center of border, they are nearer the panel so the clips don't obstruct their view
		real fiducial_x_1 = 0 + borderWidth + verticalGap;
		real fiducial_y_1 = panelHeight - (borderWidth * 2) - horizontalGap + (borderWidth / 4);
		if (exposeCardEdge == 1)
		{
			//Expose the card edge. Move the top left fiducial to the left border
			fiducial_x_1 = 0 - (borderWidth / 3) - verticalGap;
			fiducial_y_1 = panelHeight - borderWidth;
		}
		else if (leftRightFiducials == 1)
		{
			//Move the top left fiducial to the left border
			fiducial_x_1 = 0 - (borderWidth / 3) - verticalGap;
			fiducial_y_1 = panelHeight - (borderWidth * 2) - horizontalGap - (borderWidth / 2);
		}
		bigScript += "LAYER 1;\n"; //Top layer
		sprintf(s, "ADD FIDUCIAL-1X2@SPARKFUN-AESTHETICS (%.4f %.4f);\n", fiducial_x_1, fiducial_y_1);
		bigScript += s;
		sprintf(s, "ADD FIDUCIAL-1X2@SPARKFUN-AESTHETICS MR0 (%.4f %.4f);\n", fiducial_x_1, fiducial_y_1);
		bigScript += s;

		real fiducial_x_2 = panelWidth - (borderWidth * 3) - (borderWidth / 4);
		real fiducial_y_2 = panelHeight - (borderWidth * 2) - horizontalGap + (borderWidth / 4);
		if (exposeCardEdge == 1)
		{
			//Expose the card edge. Move the top right fiducial to the right border
			fiducial_x_2 = panelWidth - (borderWidth * 2) - verticalGap + (borderWidth / 3);
			fiducial_y_2 = panelHeight - borderWidth;
		}
		else if (leftRightFiducials == 1)
		{
			//Expose the card edge. Move the top right fiducial to the right border
			fiducial_x_2 = panelWidth - (borderWidth * 2) - verticalGap + (borderWidth / 3);
			fiducial_y_2 = panelHeight - (borderWidth * 2) - horizontalGap - (borderWidth / 2);
		}
		sprintf(s, "ADD FIDUCIAL-1X2@SPARKFUN-AESTHETICS (%.4f %.4f);\n", fiducial_x_2, fiducial_y_2);
		bigScript += s;
		sprintf(s, "ADD FIDUCIAL-1X2@SPARKFUN-AESTHETICS MR0 (%.4f %.4f);\n", fiducial_x_2, fiducial_y_2);
		bigScript += s;

		//Lower one - larger fiducial
		real fiducial_x_3 = 0 + borderWidth + verticalGap;
		real fiducial_y_3 = 0 - horizontalGap - (borderWidth / 4);

		if ((exposeCardEdge == 1) || (leftRightFiducials == 1))
		{
			//Expose the card edge. Move the lower fiducial to the left border
			fiducial_x_3 = 0 - (borderWidth / 3) - verticalGap;
			fiducial_y_3 = 0 + borderWidth; //+ horizontalGap;
		}

		sprintf(s, "ADD FIDUCIAL-1.5X3@SPARKFUN-RETIRED (%.4f %.4f);\n", fiducial_x_3, fiducial_y_3);
		bigScript += s;
		sprintf(s, "ADD FIDUCIAL-1.5X3@SPARKFUN-RETIRED MR0 (%.4f %.4f);\n", fiducial_x_3, fiducial_y_3);
		bigScript += s;

		bigScript += "LAYER 1;\n"; //Top layer
	}

	//Load the rules from the original design
	loadDRCfile();

	//Old way of loading DRC rules
	//Load the appropriate DRC
	// if (hasFourLayers() == 0)
	// {
	// 	bigScript += "DRC LOAD SparkFun-2-layer-PCBWay-LIMIT.dru;\n";
	// }
	// else
	// {
	// 	bigScript += "DRC LOAD SparkFun-4-layer-TIGHT.dru;\n";
	// }

	//Update the polygon pours - This can take a long time
	//bigScript += "RATSNEST;\n";

	//Save our work
	bigScript += "SET CONFIRM YES;\n";
	bigScript += "WRITE;\n";
	bigScript += "SET CONFIRM OFF;\n";
}

//Look at board dimensions and components. If any components hang over edge then warn user.
void calculateDesignDimensions()
{
	//Find min/max dimensions of this board
	char firstPoint = 'y';
	char firstPointOverhang = 'y';

	board(B)
	{
		B.wires(W)
		{
			if (W.layer == LAYER_DIMENSION)
			{
				// Wire is on dimension layer
				real wx1 = u2inch(W.x1);
				real wy1 = u2inch(W.y1);
				real wx2 = u2inch(W.x2);
				real wy2 = u2inch(W.y2);

				// Start point of wire
				if (firstPoint == 'y')
				{
					firstPoint = 'n';
					xMax = wx1;
					xMin = wx1;
					yMax = wy1;
					yMin = wy1;
				}
				else
				{
					if (wx1 > xMax)
						xMax = wx1;
					if (wx1 < xMin)
						xMin = wx1;
					if (wy1 > yMax)
						yMax = wy1;
					if (wy1 < yMin)
						yMin = wy1;
				}

				// End point of wire
				if (wx2 > xMax)
					xMax = wx2;
				if (wx2 < xMin)
					xMin = wx2;
				if (wy2 > yMax)
					yMax = wy2;
				if (wy2 < yMin)
					yMin = wy2;
			}
		}
	}

	//Check if this design has dimension lines. If it doesn't then it's probably a DXF import of an enclosure or something very weird.
	if (xMin == 0 && yMax == 0)
	{
		dlgMessageBox("!This board has no dimension lines. Cannot panelize. Exiting.");
		exit(-1);
	}

	//See if any elements of any components hang over the edge of the board dimension wires
	//Note this only looks at wires (silk lines, tdocu lines, etc). It doesn't check SMD pads
	//For example, see RedBoard: the SMD ISP header hangs over. This doesn't catch it.
	real overhang_xMax = xMax;
	real overhang_xMin = xMin;
	real overhang_yMax = yMax;
	real overhang_yMin = yMin;
	board(B)
	{
		B.elements(E)
		{

			//There are some elements we need to ignore, for example the
			//Special instruction box is all tDocu and always far outside the board outline
			if (E.package.name == "ORDERING_INSTRUCTIONS" || E.package.name == "PRODUCTION_INSTRUCTIONS")
			{
				//Ignore the location of this element
			}
			else
			{
				//Evaluate where this element resides

				E.package.wires(C)
				{

					real wx1 = u2inch(C.x1);
					real wy1 = u2inch(C.y1);
					real wx2 = u2inch(C.x2);
					real wy2 = u2inch(C.y2);

					if (wx1 > overhang_xMax)
						overhang_xMax = wx1;
					if (wx1 < overhang_xMin)
						overhang_xMin = wx1;
					if (wy1 > overhang_yMax)
						overhang_yMax = wy1;
					if (wy1 < overhang_yMin)
						overhang_yMin = wy1;

					if (wx2 > overhang_xMax)
						overhang_xMax = wx2;
					if (wx2 < overhang_xMin)
						overhang_xMin = wx2;
					if (wy2 > overhang_yMax)
						overhang_yMax = wy2;
					if (wy2 < overhang_yMin)
						overhang_yMin = wy2;
				} //End E.package.wires
			}	  //End ignore list
		}		  //End Elements
	}

	designWidth = xMax - xMin; //In inches
	designHeight = yMax - yMin;

	//Warn user if there is overhang
	if ((overhang_xMax > xMax) || (overhang_xMin < xMin) ||
		(overhang_yMax > yMax) || (overhang_yMin < yMin))
	{
		overHangingParts = "true";

		if (xMin < overhang_xMin)
			overhang_xMin = xMin;
		if (xMax > overhang_xMax)
			overhang_xMax = xMax;
		if (yMin < overhang_yMin)
			overhang_yMin = yMin;
		if (yMax > overhang_yMax)
			overhang_yMax = yMax;

		real overhangWidth = overhang_xMax - overhang_xMin;
		real overhangHeight = overhang_yMax - overhang_yMin;

		verticalGapNeeded = overhangWidth - designWidth;
		horizontalGapNeeded = overhangHeight - designHeight;
	}
}

// look at board dimensions and find the best x/y that fits close to either 5"x7" or 7"x5"
// this function originally written by Pete Lewis 3/12/2021
void calculateRecommendedPanelSize()
{
	// Note, 5"x7" is the optimal panel size for SparkFun Electronics production PnP machines.
	// But sometimes the panel can actually get closer by being 7x5.
	// Also note, to got over or under by 1/2 an inch is okay.
	// Using designWidth and designHeight we can determine what the best panel size is.
	// Need to consider the standard tabs as well (0.25"), because we want the outside of the panel to fit into 5x7 or 7x5

	// try 5x7
	// keep adding up designWidths and designHeights while stying under 5".
	real x_total_5x7 = 0;
	real y_total_5x7 = 0;
	real area_total_5x7 = 0; // used to compare with 7x5 calc and decide which is a larger area and therefore best.

	// how many copies of the board can we fit on the x axis array before we get above our max allowed?
	while ((x_total_5x7 + designWidth) < 5.0)
	{
		x_total_5x7 = x_total_5x7 + designWidth;
	}

	// how many copies of the board can we fit on the y axis array before we get above our max allowed?
	while ((y_total_5x7 + designHeight) < 7.0)
	{
		y_total_5x7 = y_total_5x7 + designHeight;
	}
	area_total_5x7 = x_total_5x7 * y_total_5x7;

	// try 7x5
	real x_total_7x5 = 0;
	real y_total_7x5 = 0;
	real area_total_7x5 = 0;
	// how many copies of the board can we fit on the x axis array before we get above our max allowed?
	while ((x_total_7x5 + designWidth) < 7.0)
	{
		x_total_7x5 = x_total_7x5 + designWidth;
	}

	// how many copies of the board can we fit on the y axis array before we get above our max allowed?
	while ((y_total_7x5 + designHeight) < 5.0)
	{
		y_total_7x5 = y_total_7x5 + designHeight;
	}
	area_total_7x5 = x_total_7x5 * y_total_7x5;

	// see which option has the best use of the area of the panel

	if (area_total_5x7 > area_total_7x5)
	{
		recPanelWidth = x_total_5x7;
		recPanelHeight = y_total_5x7;
	}
	else
	{
		recPanelWidth = x_total_7x5;
		recPanelHeight = y_total_7x5;
	}

	// add in panel tabs (each one is 0.25 inchs = 0.5 inch addition)
	recPanelWidth = recPanelWidth + 0.5;
	recPanelHeight = recPanelHeight + 0.5;
}

//Change any / in a string to \
//Useful for directory structure before calling a cmd
string convertForwardToBackSlashes(string thing)
{
	//Convert forward slashes to back slashes so we can run system command
	int pos = strrchr(thing, '/');
	while (pos >= 0)
	{
		//thing = strsub(thing, 0, pos) + "\\\\" + strsub(thing, pos + 1, strlen(thing)); //Remove and replace
		thing = strsub(thing, 0, pos) + "\\" + strsub(thing, pos + 1, strlen(thing)); //Remove and replace
		pos = strrchr(thing, '/');													  //Look for the next forward slash
	}
	return (thing);
}

//Creates a sub directory to the project called \Panel to store the new panel brd file into
void createFile()
{
	//Get the name of this brd (no extension, no directory)
	string baseFileName = get_project_name();

	//See if this panel already exists. If yes, ask user to overwrite
	string a[];
	string projectDirectory = get_project_path();
	panelFileLocation = projectDirectory + "Production/" + baseFileName + "-Panel.brd";
	int n = fileglob(a, panelFileLocation);

	string rootPanelFileName = projectDirectory + "Production/" + baseFileName + "-Panel"; //Just the file name, no extension

	//Warn user we are about to overwrite a file of the same name
	if (n != 0)
	{
		if (dlgMessageBox("!You are about to write over a panel file.\nAre you sure?", "&Yes", "&No") != 0)
		{
			exit(0); //Bail
		}
	}

	projectDirectory = convertForwardToBackSlashes(projectDirectory); //Convert forward slashes to back slashes so we can run system command

	//Make the production directory if one does not exist
	string commandToRun = "cmd.exe /C IF NOT EXIST " + "\"" + projectDirectory + "\\Production\" md \"" + projectDirectory + "\\Production\""; // /K to keep window open
	if (system(commandToRun) != 0)
	{
		dlgMessageBox("Error: Command failed.", "OK");
	}

	//Create link to the production folder to save the design rules
	designRulesLocation = get_project_path() + "Production/" + baseFileName + ".dru";
}

void removeOldFiles()
{
	//Get the name of this brd (no extension, no directory)
	string baseFileName = get_project_name();
	string projectDirectory = get_project_path();
	string commandToRun;

	//Remove any files in the production folder left over from previous panel CAM
	sprintf(commandToRun, "cmd.exe /C del \"%sProduction\\%s-Panel.*\"", projectDirectory, baseFileName);
	if (system(commandToRun) != 0)
	{
		dlgMessageBox("Error: Command failed.", "OK");
	}

	sprintf(commandToRun, "cmd.exe /C del \"%sProduction\\ordering_instructions.TXT\"", projectDirectory);
	if (system(commandToRun) != 0)
	{
		dlgMessageBox("Error: Command failed.", "OK");
	}
}

//Calculate the smallest trace width, returns value in mm
//Code based on https://github.com/CalPolyFSAE/EAGLE-Designs/blob/master/EAGLE%20ULP/pcb-service.ulp
real CalcMinTraceWidth(void)
{
	real minTraceWidth = 10.0;
	board(B)
	{
		B.wires(W) if (W.layer <= 16) minTraceWidth = min(u2mm(W.width), minTraceWidth);
		B.signals(S)
		{
			//S.polygons(P) if (P.layer <= 16) minTraceWidth = min(u2mm(P.width), minTraceWidth);
			S.wires(W) if (W.layer <= 16) minTraceWidth = min(u2mm(W.width), minTraceWidth);
		}
	}
	return (minTraceWidth);
}

//Calculate the smallest drill size, returns value in mm
//Code based on https://github.com/CalPolyFSAE/EAGLE-Designs/blob/master/EAGLE%20ULP/pcb-service.ulp
real CalcMinDrillSize()
{
	real minDrillSize = 10.0;
	board(B)
	{
		B.holes(H)
		{
			minDrillSize = min(u2mm(H.drill), minDrillSize);
		}

		B.signals(S)
		{
			S.vias(V)
			{
				minDrillSize = min(u2mm(V.drill), minDrillSize);
			}
		}

		B.elements(E)
		{
			E.package.contacts(C) if (C.pad)
				minDrillSize = min(u2mm(C.pad.drill), minDrillSize);
			E.package.holes(H) minDrillSize = min(u2mm(H.drill), minDrillSize);
		}
	}
	return (minDrillSize);
}

//Record board thickness, soldermask color, silkscreen color, oz copper, and plating to a text file
//Min trace width,
void orderingInstructionsWrite()
{
	string orderingFile = get_project_path() + "Production/ordering_instructions.txt";

	//Convert panel dimensions to mm
	panelHeight *= 25.4;
	panelWidth *= 25.4;

	int numberOfLayers = 2;
	if (hasFourLayers() == 1)
		numberOfLayers = 4;

	if (hasSixLayers() == 1)
		numberOfLayers = 6;

	string stencilsRequired = "none";
	//if(hasTopParts() && hasBottomParts()) stencilsRequired = "top+bottom";
	//else if(hasTopParts()) stencilsRequired = "top";
	//else if(hasBottomParts()) stencilsRequired = "bottom";
	if (generateTopStencil && generateBottomStencil)
		stencilsRequired = "top+bottom";
	else if (generateTopStencil)
		stencilsRequired = "top";
	else if (generateBottomStencil)
		stencilsRequired = "bottom";

	string boardThickness = getBoardThickness(); //Search for 0.8mm text on board
	string boardColor = getBoardColor();		 //Search board for aesthetics to determine soldermask color
	string surfaceFinish = getSurfaceFinish();	 // Search board for surface finish
	string copperWeight = getCopperWeight();	 // Search board for copper weight

	int pcsPerPanel = numberOfColumns * numberOfRows; //Total count per panel. Helps when figuring out the number of panels to order

	string boardSilkColor = "White"; //Almost all boards have white silkscreen. Only the white soldermask boards (Google-IOIO) require black silk
	if (boardColor == "White")
	{
		boardSilkColor = "Black";
	}

	real minTraceWidth = CalcMinTraceWidth();

	real minDrillSize = CalcMinDrillSize();

	output(orderingFile)
	{
		printf("panel size, %.0fx%.0fmm\n", ceil(panelWidth), ceil(panelHeight));
		printf("PCB thickness, %s\n", boardThickness);
		printf("number of layers, %d\n", numberOfLayers);
		printf("soldermask color, %s\n", boardColor);
		printf("silkscreen color, %s\n", boardSilkColor);
		printf("oz copper, %s\n", copperWeight);
		printf("finish, %s\n", surfaceFinish);
		printf("stencils, %s\n", stencilsRequired);
		printf("pcs per panel, %d\n", pcsPerPanel);
		printf("min trace width, %.4fmm / %.4fin\n", minTraceWidth, convertMMToInches(minTraceWidth));
		printf("min drill size, %.4fmm / %.4fin\n", minDrillSize, convertMMToInches(minDrillSize));
		if (numberOfLayers == 4)
		{
			printf("filename to layer stackup 1/2/3/4: GTL, GL2, GL3, GBL\n");
		}
		if (numberOfLayers == 6)
		{
			printf("filename to layer stackup 1/2/3/4/5/6: GTL, GL2, GL3, GL4, GL5, GBL\n");
		}
	}
}

//Check for unrouted nets
//Returns true if board has unrouted nets
int unroutedNets(void)
{
	int unroutedNets = false;

	if (board)
	{
		board(B)
		{
			B.signals(S)
			{
				S.wires(W)
				{
					if (W.layer == LAYER_UNROUTED)
						unroutedNets = true;
				}
			}
		}

		if (unroutedNets == true)
			return (true);
	}
	return (false);
}

//Starting in eagle v8, the group command changed. These scripts rely on being able
//to precisely control the group command. If the "ground command default on" is checked,
//then the scripts fail because the group command is too close to the board edge and eagle
//automatically goes to a move command. This function reads the current state, stores the
//user's setting in a global for future reset, and then disables the setting.
int usersGroupCommandSetting;
void setGroupDefault()
{
	/*
	We attempt to read the setting here but it's not documented
	board(B) {
		usersGroupCommandSetting = B.groupdefault;
	}

	//run C:\Users\OldLenny\Dropbox\Projects\SparkFun_Eagle_Settings\ulp\sparkfun-panelizer.ulp
	string s;
	sprintf(s, "Setting: %d", userGroupCommandSetting);
	dlgMessageBox(s);
	exit(0);

	bigScript += "SET GROUP_DEFAULT OFF;\n"; //Not documented but works



	*/
}

//This is the main function
if (schematic)
{
	exit("edit .brd; run " + argv[0] + " " + argv[1]);
}
else if (board)
{
	configRead(); //Read any settings if available

	setGroupDefault(); //Remember, then turn off the "Group default command on" setting

	//Check this design for unrouted nets
	if (unroutedNets() == true)
	{
		string warning = "!This design has unrouted nets! Are you sure you want to continue?";

		if (dlgMessageBox(warning, "&Yes", "&No") == 1)
		{
			//Bail
			exit(1);
		}
	}

	createFile(); //Create a \Panel sub directory, overwrite any existing panel files

	calculateDesignDimensions(); //Detect any overhanging parts. It will set designWidth/designHeight

	calculateRecommendedPanelSize(); // look at board dimensions and find the best x/y that fits close to either 5"x7" or 7"x5"

	string horizontalGapString = "";
	string verticalGapString = "";
	string designXYString = "";
	string recommendedPanelSizeString = "";

	//We have to create the strings before the GUI is loaded
	if (panelUnits == 0) //Inches
	{
		if (verticalGapNeeded > 0.02 && verticalGapNeeded < 0.12)
			verticalGapNeeded = 0.12;
		if (horizontalGapNeeded > 0.02 && horizontalGapNeeded < 0.12)
			horizontalGapNeeded = 0.12;
	}
	else
	{
		verticalGapNeeded = convertInchToMM(verticalGapNeeded);
		horizontalGapNeeded = convertInchToMM(horizontalGapNeeded);
		if (verticalGapNeeded > 0.51 && verticalGapNeeded < 3)
			verticalGapNeeded = 3;
		if (horizontalGapNeeded > 0.51 && horizontalGapNeeded < 3)
			horizontalGapNeeded = 3;
		designWidth = convertInchToMM(designWidth);
		designHeight = convertInchToMM(designHeight);
		recPanelWidth = convertInchToMM(recPanelWidth);
		recPanelHeight = convertInchToMM(recPanelHeight);
	}

	sprintf(verticalGapString, "Recommended Vertical Gap for Overhang: %.2f", verticalGapNeeded);
	sprintf(horizontalGapString, "Recommended Horizontal Gap for Overhang: %.2f", horizontalGapNeeded);
	sprintf(designXYString, "Design Width x Height: %.2f x %.2f", designWidth, designHeight);
	sprintf(recommendedPanelSizeString, "Recommended Panel Size: %.2f x %.2f", recPanelWidth, recPanelHeight);

	// start out the GUI with the recommended panel sizes, but the user can change them as needed
	// check to see if the config file exhists (set in configRead())
	// if it exhists, that means the user may have already used the ULP once, and we want to use their previous
	// settings, not the recommended.
	if (configFileExists == 0)
	{
		// add 5% so that the panelizer tool will still work.
		// if it is exactly the size we want, then it will not attempt/expand to our desired x/y
		panelSizeX = recPanelWidth * 1.05;
		panelSizeY = recPanelHeight * 1.05;
	}

	//GUI
	int dstatus = dlgDialog("Panel Generation Options")
	{

		dlgGroup("Dimensions")
		{
			dlgRadioButton("Inches", panelUnits)
			{
				//Convert vars to inches
				panelSizeX = convertMMToInches(panelSizeX);
				panelSizeY = convertMMToInches(panelSizeY);
				verticalGap = convertMMToInches(verticalGap);
				horizontalGap = convertMMToInches(horizontalGap);
				verticalGapNeeded = convertMMToInches(verticalGapNeeded);
				horizontalGapNeeded = convertMMToInches(horizontalGapNeeded);
				designWidth = convertMMToInches(designWidth);
				designHeight = convertMMToInches(designHeight);
				recPanelWidth = convertMMToInches(recPanelWidth);
				recPanelHeight = convertMMToInches(recPanelHeight);

				//PCBWay & JLCPCB requires 3mm minimum for route-out areas
				if (verticalGapNeeded > 0.02 && verticalGapNeeded < 0.12)
					verticalGapNeeded = 0.12;
				if (horizontalGapNeeded > 0.02 && horizontalGapNeeded < 0.12)
					horizontalGapNeeded = 0.12;
				sprintf(verticalGapString, "Recommended Vertical Gap for Overhang: %.2f", verticalGapNeeded);
				sprintf(horizontalGapString, "Recommended Horizontal Gap for Overhang: %.2f", horizontalGapNeeded);
				sprintf(designXYString, "Design Width x Height: %.2f x %.2f", designWidth, designHeight);
				sprintf(recommendedPanelSizeString, "Recommended Panel Size: %.2f x %.2f", recPanelWidth, recPanelHeight);

				dlgRedisplay();
			}
			dlgRadioButton("Millimeters", panelUnits)
			{
				//Convert vars to mm
				panelSizeX = convertInchToMM(panelSizeX);
				panelSizeY = convertInchToMM(panelSizeY);
				verticalGap = convertInchToMM(verticalGap);
				horizontalGap = convertInchToMM(horizontalGap);
				verticalGapNeeded = convertInchToMM(verticalGapNeeded);
				horizontalGapNeeded = convertInchToMM(horizontalGapNeeded);
				designWidth = convertInchToMM(designWidth);
				designHeight = convertInchToMM(designHeight);
				recPanelWidth = convertInchToMM(recPanelWidth);
				recPanelHeight = convertInchToMM(recPanelHeight);

				//PCBWay & JLCPCB requires 3mm minimum for route-out areas
				if (verticalGapNeeded > 0.51 && verticalGapNeeded < 3)
					verticalGapNeeded = 3;
				if (horizontalGapNeeded > 0.51 && horizontalGapNeeded < 3)
					horizontalGapNeeded = 3;
				sprintf(verticalGapString, "Recommended Vertical Gap for Overhang: %.2f", verticalGapNeeded);
				sprintf(horizontalGapString, "Recommended Horizontal Gap for Overhang: %.2f", horizontalGapNeeded);
				sprintf(designXYString, "Design Width x Height: %.2f x %.2f", designWidth, designHeight);
				sprintf(recommendedPanelSizeString, "Recommended Panel Size: %.2f x %.2f", recPanelWidth, recPanelHeight);

				dlgRedisplay();
			}
		}

		dlgGroup("Panel Size")
		{
			dlgLabel(designXYString, 1);
			dlgRadioButton("Must be smaller than", panelMustBeLargerThanDimension);
			dlgRadioButton("Must be larger than", panelMustBeLargerThanDimension);

			dlgHBoxLayout
			{
				dlgLabel("X:\t");
				dlgRealEdit(panelSizeX, 1, 600);
			}
			dlgHBoxLayout
			{
				dlgLabel("Y:\t");
				dlgRealEdit(panelSizeY, 1, 600);
			}
			dlgLabel(recommendedPanelSizeString, 1);
		}

		dlgGroup("Gaps")
		{

			if (overHangingParts == "true")
			{
				dlgHBoxLayout { dlgLabel("<font color=red>Note:</font> This board has overhanging parts\t"); }
				dlgHBoxLayout { dlgLabel("PCBWay & JLCPCB: 3mm min routeout gap\t"); }
				if (verticalGapNeeded > 0)
				{
					dlgHBoxLayout { dlgLabel(verticalGapString, 1); } //Change with redisplay
				}

				if (horizontalGapNeeded > 0)
				{
					dlgHBoxLayout { dlgLabel(horizontalGapString, 1); } //Change with redisplay
				}
			}

			dlgHBoxLayout
			{
				dlgLabel("Vertical Gap:\t");
				dlgRealEdit(verticalGap, 0.0, 15);
			}
			dlgHBoxLayout
			{
				dlgLabel("Horizontal Gap:\t");
				dlgRealEdit(horizontalGap, 0.0, 15);
			}
		}

		dlgGroup("Extra Production Bits")
		{
			dlgHBoxLayout { dlgCheckBox("Add Panel Borders and Fiducials", drawPanelBorders); }
			dlgHBoxLayout { dlgCheckBox("Expose Bottom/Card Edge", exposeCardEdge); }
			dlgHBoxLayout { dlgCheckBox("Add V-score Lines and Text", vScoreIndicators); }
			dlgHBoxLayout { dlgCheckBox("Move Panel Fiducials to Left+Right Edges", leftRightFiducials); }
		}

		dlgGroup("Stencil Generation")
		{
			if (hasBottomParts() == 1)
			{
				dlgHBoxLayout
				{
					dlgLabel("<font color=red>Note:</font> This board has parts on bottom side: <br>" + bottomPackages);
				}
			}

			dlgHBoxLayout { dlgCheckBox("Top Stencil", generateTopStencil); }
			if (hasBottomParts() == 1)
			{
				dlgHBoxLayout { dlgCheckBox("Bottom Stencil", generateBottomStencil); }
			}
		}

		if (hasFourLayers() == 1)
		{
			dlgHBoxLayout { dlgLabel("<font color=red>Note:</font> This is a four layer board\t"); }
			dlgHBoxLayout { dlgLabel("\t"); }
		}

		dlgGroup("Output Files")
		{
			dlgHBoxLayout { dlgCheckBox("Run CAM after panelization", runCAM); }
		}

		dlgPushButton("+&Generate")
		{

			if ((horizontalGap > 0.02 && horizontalGap < 0.12) || (verticalGap > 0.02 && verticalGap < 0.12))
				dlgMessageBox("PCBWay requires 0.12\" or 3mm min distance for route outs. This panel may fail review.");

			configWrite(); //Record current settings

			//Before we begin, make sure the incoming units are in inches
			if (panelUnits == 1) //User input mm
			{
				//Convert panel units from mm to inches
				panelSizeX = convertMMToInches(panelSizeX);
				panelSizeY = convertMMToInches(panelSizeY);
				verticalGap = convertMMToInches(verticalGap);
				horizontalGap = convertMMToInches(horizontalGap);
			}

			if (panelSizeX > 11.8 || panelSizeY > 11.8)
			{
				if (dlgMessageBox("Generally, the max X or Y dimension is 11.8\". This is a big panel and may cost extra. Do you wish to continue?", "&Yes", "&No") != 0)
				{
					//Bail
					exit(-1);
				}
			}

			removeOldFiles(); //Remove old gerbers, zip, ordering instructions, and brd if exists

			panelizer(); //Create the panel

			orderingInstructionsWrite(); //Record board characteristics

			if (runCAM == 1)
			{
				bigScript += "RUN SparkFun-CAMmer.ulp;\n";
			}

			//exit(bigScript); //Execute this generated script

			//Output this script to a formal script file for faster execution and easier debugging
			string scriptFile = filedir(argv[0]) + "SparkFun-Panelizer.scr";
			output(scriptFile)
				printf("%s", bigScript); //Write bigScript to the file
			//Now run script
			string s;
			sprintf(s, "SCRIPT %s;\n", scriptFile);
			exit(s);

			dlgAccept(-1);
		}

		dlgStretch(1);
	};

	configWrite(); //Record current settings
}
else
{
	dlgMessageBox("Please run SparkFun Panelizer from a board.");
	exit(1);
}

/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2020 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "math.h"
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/

DAC_HandleTypeDef hdac;
DMA_HandleTypeDef hdma_dac1;

TIM_HandleTypeDef htim2;

/* USER CODE BEGIN PV */

/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_DAC_Init(void);
static void MX_DMA_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */
#define   SINE_RES          128                                  // Waveform resolution
//#define   CNT_FREQ          90000000                             // TIM6 counter clock (prescaled APB1)

uint32_t out[10000];
uint32_t sampleindex = 0;
uint32_t blocksize = 0;
uint32_t timer = 100000;
uint32_t frequency = 100;
uint32_t stuetz = 100;
uint32_t sine_val[100];

uint32_t bpm = 0;
uint32_t bpm_in_ms = 0;

uint32_t cnt_freq = 90000000;


uint32_t osc_1_current_freq;
uint32_t osc_1_sine_res = 128;
uint32_t osc_1_tim_period;
uint32_t count = 0;


float notes[108] = {
16.35,		// C0
17.32,
18.35,
19.45,
20.6,
21.83,
23.12,
24.5,
25.96,
27.5,
29.14,
30.87,
32.7,		// C1
34.65,
36.71,
38.89,
41.2,
43.65,
46.25,
49,
51.91,
55,
58.27,
61.74,
65.41,		// C2
69.3,
73.42,
77.78,
82.41,
87.31,
92.5,
98,
103.83,
110,
116.54,
123.47,
130.81,		// C3
138.59,
146.83,
155.56,
164.81,
174.61,
185,
196,
207.65,
220,
233.08,
246.94,
261.63,		// C4
277.18,
293.66,
311.13,
329.63,
349.23,
369.99,
392,
415.3,
440,
466.16,
493.88,
523.25,		// C5
554.37,
587.33,
622.25,
659.25,
698.46,
739.99,
783.99,
830.61,
880,
932.33,
987.77,
1046.5,		// C6
1108.73,
1174.66,
1244.51,
1318.51,
1396.91,
1479.98,
1567.98,
1661.22,
1760,
1864.66,
1975.53,
2093,		// C7
2217.46,
2349.32,
2489.02,
2637.02,
2793.83,
2959.96,
3135.96,
3322.44,
3520,
3729.31,
3951.07,
4186.01,	// C8
4434.92,
4698.63,
4978.03,
5274.04,
5587.65,
5919.91,
6271.93,
6644.88,
7040,
7458.62,
7902.13};

// Oktavenüberlauf anders lösen da get_keyindex() schon das erste Match nimmt
char keys[26] = {'C','C#','D','D#','E','F','F#','G','G#','A','B','H','C','C#','D','D#','E','F','F#','G','G#','A','B','H','C','C#'};

uint32_t keyindex = 0;

uint32_t major_scale[9] =  {0,2,4,5,7,9,11,12,14}; 	// {2,2,1,2,2,2,1};
uint32_t major_chords[9] = {0,1,1,0,0,1, 2, 0, 1}; 	// 0: major, 1: minor, 2: diminished

uint32_t minor_scale[9] =  {0,2,3,5,7,8,10,12,14};	// {2,1,2,2,1,2,2};
uint32_t minor_chords[9] = {1,2,0,1,1,0, 0, 1, 2};	// 0: major, 1: minor, 2: diminished

// if chord is diminished (equals 2), last tone of array
// is reduced by a semitone, e.g. pos. 5 of major scale equals 7 >> dim = 6
uint32_t chord_5[4] = {1,3,5,3};
uint32_t chord_7[4] = {1,3,5,7};
uint32_t chord_9[4] = {1,3,5,9};


uint32_t function[SINE_RES] = { 2048, 2145, 2242, 2339, 2435, 2530, 2624, 2717, 2808, 2897,
		2984, 3069, 3151, 3230, 3307, 3381, 3451, 3518, 3581, 3640,
		3696, 3748, 3795, 3838, 3877, 3911, 3941, 3966, 3986, 4002,
		4013, 4019, 4020, 4016, 4008, 3995, 3977, 3954, 3926, 3894,
		3858, 3817, 3772, 3722, 3669, 3611, 3550, 3485, 3416, 3344,
		3269, 3191, 3110, 3027, 2941, 2853, 2763, 2671, 2578, 2483,
		2387, 2291, 2194, 2096, 1999, 1901, 1804, 1708, 1612, 1517,
		1424, 1332, 1242, 1154, 1068, 985, 904, 826, 751, 679,
		610, 545, 484, 426, 373, 323, 278, 237, 201, 169,
		141, 118, 100, 87, 79, 75, 76, 82, 93, 109,
		129, 154, 184, 218, 257, 300, 347, 399, 455, 514,
		577, 644, 714, 788, 865, 944, 1026, 1111, 1198, 1287,
		1378, 1471, 1565, 1660, 1756, 1853, 1950, 2047 };


#define PI 3.1415926

void osc_1_play_note(uint32_t keyindex, uint32_t sex, uint32_t chordpos, uint32_t delay, uint32_t beat, uint32_t octave){

	if(sex == 0){

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[chordpos]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(beat*delay/4);
	}
	if(sex == 1){

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[chordpos]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(beat*delay/4);
	}
}

void get_keyindex(char key){

	keyindex = 0;

	for(int i = 0; i < 12; i++){
		if(key == keys[i]) keyindex = i;
	}
}

void osc_1_play_chord(char key, uint32_t sex, uint32_t delay, uint32_t octave, uint32_t chordtype){

	// sex...0: major, 1: minor, 2: diminished

	get_keyindex(key);
	if(keyindex >= 12) octave++;

	for(int i = 0; i < 4; i++){

		if(chordtype==5){

			if(i==3 && sex == 2){

				osc_1_play_note(keyindex, sex, chord_5[i]-1-1, delay, 1, octave);
			}
			else{
				osc_1_play_note(keyindex, sex, chord_5[i]-1, delay, 1, octave);
			}
		}

		if(chordtype==7){

			if(i==3 && sex == 2){

				osc_1_play_note(keyindex, sex, chord_7[i]-1-1, delay, 1, octave);
			}
			else{
				osc_1_play_note(keyindex, sex, chord_7[i]-1, delay, 1, octave);
			}

		}
		if(chordtype==9){

			if(i==3 && sex == 2){

				osc_1_play_note(keyindex, sex, chord_7[i]-1-1, delay, 1, octave);
			}
			else{
				osc_1_play_note(keyindex, sex, chord_7[i]-1, delay, 1, octave);
			}
		}
	}
}

void osc_1_play_major_chord(char key, uint32_t delay, uint32_t octave, uint32_t chordtype){

	int keyindex = 0;

	for(int i = 0; i < 12; i++){
		if(key == keys[i]) keyindex = i;
	}

	osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[0]];
	osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
	htim2.Init.Period = (uint32_t)osc_1_tim_period;
	HAL_TIM_Base_Init(&htim2);
	HAL_Delay(delay/4);

	osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[2]];
	osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
	htim2.Init.Period = (uint32_t)osc_1_tim_period;
	HAL_TIM_Base_Init(&htim2);
	HAL_Delay(delay/4);

	osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[4]];
	osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
	htim2.Init.Period = (uint32_t)osc_1_tim_period;
	HAL_TIM_Base_Init(&htim2);
	HAL_Delay(delay/4);

	if(chordtype == 5){

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[2]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay/4);
	}

	if(chordtype == 7){

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[chordtype-1]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay/4);
	}

	if(chordtype == 9){

		chordtype = 2;
		octave +=1;

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[chordtype-1]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay/4);
	}

}


void osc_1_play_minor_chord(char key, uint32_t delay, uint32_t octave, uint32_t chordtype){

	int keyindex = 0;

	for(int i = 0; i < 12; i++){
		if(key == keys[i]) keyindex = i;
	}


	osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[0]];
	osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
	htim2.Init.Period = (uint32_t)osc_1_tim_period;
	HAL_TIM_Base_Init(&htim2);
	HAL_Delay(delay/4);

	osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[2]];
	osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
	htim2.Init.Period = (uint32_t)osc_1_tim_period;
	HAL_TIM_Base_Init(&htim2);
	HAL_Delay(delay/4);

	osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[4]];
	osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
	htim2.Init.Period = (uint32_t)osc_1_tim_period;
	HAL_TIM_Base_Init(&htim2);
	HAL_Delay(delay/4);

	if(chordtype == 5){

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[2]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay/4);
	}

	if(chordtype == 7){

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[chordtype-1]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay/4);
	}

	if(chordtype == 9){

		chordtype = 2;
		octave +=1;

		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[chordtype-1]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay/4);
	}
}


void osc_1_play_major_scale(char key, uint32_t delay, uint32_t octave){

	int keyindex = 0;

	for(int i = 0; i < 12; i++){
		if(key == keys[i]) keyindex = i;
	}

	for(uint32_t i = 0; i < 8; i++)
	{
		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[i]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay);
	}

	for(uint32_t i = 0; i < 8; i++)
	{
		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+major_scale[7-i]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay);
	}
}


void osc_1_play_minor_scale(char key, uint32_t delay, uint32_t octave){

	int keyindex = 0;

	for(int i = 0; i < 12; i++){
		if(key == keys[i]) keyindex = i;
	}

	for(uint32_t i = 0; i < 8; i++)
	{
		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[i]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay);
	}

	for(uint32_t i = 0; i < 8; i++)
	{
		osc_1_current_freq = (uint32_t)notes[12*octave+keyindex+minor_scale[7-i]];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay);
	}
}


void osc_1_play_all_semitones(uint32_t delay, uint32_t octave){


	for(uint32_t i = 0; i < 12; i++)
	{
		osc_1_current_freq = (uint32_t)notes[12*octave+i];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay);
	}

	for(uint32_t i = 0; i < 12; i++)
	{
		osc_1_current_freq = (uint32_t)notes[12*octave+(11-i)];
		osc_1_tim_period = ((cnt_freq)/((osc_1_sine_res)*(osc_1_current_freq)));
		htim2.Init.Period = (uint32_t)osc_1_tim_period;
		HAL_TIM_Base_Init(&htim2);
		HAL_Delay(delay);
	}

}


void play_melody_1(){

	osc_1_play_major_chord('F', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('F', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);

	osc_1_play_major_chord('F', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('F', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 7);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 7);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 9);

	osc_1_play_major_chord('B', bpm_in_ms, 2, 9);
	osc_1_play_major_chord('B', bpm_in_ms, 2, 9);
	osc_1_play_major_chord('B', bpm_in_ms, 2, 7);
	osc_1_play_major_chord('F', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 7);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);

	osc_1_play_major_chord('B', bpm_in_ms, 2, 5);
	osc_1_play_major_chord('B', bpm_in_ms, 2, 5);
	osc_1_play_major_chord('B', bpm_in_ms, 2, 9);
	osc_1_play_major_chord('F', bpm_in_ms, 3, 7);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 7);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 9);
}

void play_melody_2(){


	osc_1_play_major_chord('G', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('G', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('A', bpm_in_ms, 2, 5);
	osc_1_play_major_chord('A', bpm_in_ms, 2, 5);
	osc_1_play_major_chord('A', bpm_in_ms, 2, 7);
	osc_1_play_major_chord('A', bpm_in_ms, 2, 9);

	osc_1_play_major_chord('G', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('G', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('D', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 5);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 9);
	osc_1_play_major_chord('C', bpm_in_ms, 3, 7);

	}

uint32_t createRandoms(int lower, int upper)
{
	uint32_t num = (rand() % (upper - lower + 1)) + lower;
    return num;
}

void play_melody_random(char key, uint32_t sex, uint32_t rnd){

	get_keyindex(key);

	//uint32_t rnd = createRandoms(1, 8);

	if(sex == 0){

		osc_1_play_chord(keys[keyindex+major_scale[rnd]], major_chords[rnd], bpm_in_ms, 3, 5);
		//osc_1_play_chord(keys[keyindex+major_scale[rnd]], major_chords[rnd], bpm_in_ms, 3, 9);
		//osc_1_play_chord(keys[keyindex+major_scale[rnd]], major_chords[rnd], bpm_in_ms, 3, 5);
	}
	if(sex == 1){

		osc_1_play_chord(keys[keyindex+minor_scale[rnd]], minor_chords[rnd], bpm_in_ms, 3, 5);
		//osc_1_play_chord(keys[keyindex+minor_scale[rnd]], minor_chords[rnd], bpm_in_ms, 3, 5);
	}
}


/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{
	/* USER CODE BEGIN 1 */
 	MX_DMA_Init();
	/* USER CODE END 1 */


	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_DAC_Init();
	MX_DMA_Init();
	MX_TIM2_Init();

	/* USER CODE BEGIN 2 */
	HAL_TIM_Base_Start(&htim2);
	HAL_DAC_Start_DMA(&hdac, DAC_CHANNEL_1, function, osc_1_sine_res, DAC_ALIGN_12B_R);

	bpm = 62;
	bpm_in_ms = (uint32_t)60*1000 / bpm;

	frequency = 0;
	/* USER CODE END 2 */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		//play_melody_random('E', 0, frequency);
		//frequency++;
		//if(frequency == 9) frequency = 0;

		play_melody_2();

		/* USER CODE END WHILE */


		/* USER CODE BEGIN 3 */

		/* USER CODE END 3 */
	}
}
/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

	/** Configure the main internal regulator output voltage
	 */
	__HAL_RCC_PWR_CLK_ENABLE();
	__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
	/** Initializes the CPU, AHB and APB busses clocks
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 4;
	RCC_OscInitStruct.PLL.PLLN = 180;
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
	RCC_OscInitStruct.PLL.PLLQ = 3;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}
	/** Initializes the CPU, AHB and APB busses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
			|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
	{
		Error_Handler();
	}
}

/**
 * @brief DAC Initialization Function
 * @param None
 * @retval None
 */
static void MX_DAC_Init(void)
{

	/* USER CODE BEGIN DAC_Init 0 */

	/* USER CODE END DAC_Init 0 */

	DAC_ChannelConfTypeDef sConfig = {0};

	/* USER CODE BEGIN DAC_Init 1 */

	/* USER CODE END DAC_Init 1 */
	/** DAC Initialization
	 */
	hdac.Instance = DAC;
	if (HAL_DAC_Init(&hdac) != HAL_OK)
	{
		Error_Handler();
	}
	/** DAC channel OUT1 config
	 */
	sConfig.DAC_Trigger = DAC_TRIGGER_T2_TRGO;
	sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
	if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN DAC_Init 2 */

	/* USER CODE END DAC_Init 2 */

}

/**
 * @brief TIM2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM2_Init(void)
{

	/* USER CODE BEGIN TIM2_Init 0 */

	/* USER CODE END TIM2_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM2_Init 1 */

	/* USER CODE END TIM2_Init 1 */
	htim2.Instance = TIM2;
	htim2.Init.Prescaler = 0;					// >> 1 MHz
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim2.Init.Period = osc_1_tim_period;						// >> 100KHz / (stuetz*blocksize) == 1
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
	{
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM2_Init 2 */

	/* USER CODE END TIM2_Init 2 */

}

/** 
 * Enable DMA controller clock
 */
static void MX_DMA_Init(void) 
{

	/* DMA controller clock enable */
	__HAL_RCC_DMA1_CLK_ENABLE();

	/* DMA interrupt init */
	/* DMA1_Stream5_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);

}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOH_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();

}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */

	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{ 
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
     tex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
